<p>﻿—
layout: post
title: POJ 1308 Is It A Tree?
date: 2014-07-22 04:16:00
categories: Exercise
toc: true
—</p>
<h1 id="section">题目</h1>
<p>源地址：</p>

<p>http://poj.org/problem?id=1308</p>

<h1 id="section-1">理解</h1>
<p>同样是并查集的应用，难点在于如何判断给定的点之间是否形成了森林。事实上，只要判断树与树之间有没有成环即可。</p>

<!-- more -->

<h1 id="section-2">代码</h1>

<div class="highlighter-rouge"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#define N 1000

int father[N], rank[N];

void makeset(int x)
{
    father[x] = x;
    rank[x] = 0;
}

int find(int x)
{
    if (x != father[x])    father[x] = find(father[x]);
    return father[x];
}

int Union(int x, int y)
{    x = find(x);
    y = find(y);
    if (x == y)    return 0;
    if (rank[x] &gt; rank[y]) father[y] = x;
    else
    {
        if (rank[x] == rank[y])    rank[y]++;
        father[x] = y;
    }
    return 1;
}

int main(int argc, char const *argv[])
{
    int k = 1;
    int a, b;
    int flag = 0;
    register int i;
    for (i = 0; i &lt; N; i++)    makeset(i);
    while (scanf("%d%d", &amp;a, &amp;b) != EOF &amp;&amp; a &gt;= 0 &amp;&amp; b &gt;= 0)
    {
        if (!a &amp;&amp; !b)
        {
            int cnt = 0;
            for (i = 0; i &lt; N; i++)
                if (father[i] == i &amp;&amp; rank[i])
                    cnt++;
            if (cnt &gt; 1)   flag = 1;
            if (!flag)
                printf("Case %d is a tree.\n", k++);
            else
                printf("Case %d is not a tree.\n", k++);
            for (i = 0; i &lt; N; i++)    makeset(i);
            flag = 0;
            continue;
        }
        if (!flag &amp;&amp; !Union(a, b))    flag = 1;
    }
    return 0;
    }

</code></pre>
</div>

<h1 id="section-3">更新日志</h1>
<ul>
  <li>2014年07月22日 已AC。</li>
</ul>
